## Overview

`tailwind-dynamic-breakpoints` is a CLI tool designed to dynamically generate CSS for arbitrary breakpoints in Tailwind CSS. It scans your project files for classes that utilize dynamic breakpoints (e.g., `media-max-1209:text-black`), generates the corresponding CSS using Tailwind, and combines everything into a single output CSS file.

## Features

- Scans specified files for dynamic breakpoint classes within your project (HTML, JSX, etc.).
- Generates CSS rules for these dynamic breakpoints using Tailwind CSS and PostCSS.
- Consolidates generated CSS into a single, clean output file.
- Supports file watching (`--watch`) for automatic regeneration of CSS on changes, enhancing developer experience.
- Allows execution of a custom command (`--post-command`) after successful CSS generation, useful for chaining build steps.

## Installation

To integrate `tailwind-dynamic-breakpoints` into your project, simply install it as a development dependency using your preferred package manager:

```bash
# Using npm
npm install tailwind-dynamic-breakpoints --save-dev

# Or using yarn
yarn add tailwind-dynamic-breakpoints --dev
```

## Usage

Once installed, `tailwind-dynamic-breakpoints` can be run from your project's root directory or within an npm script.

### Basic Execution

To run the tool with default settings (output to `./dynamic-breakpoints.css`, using `tailwind.config.js`):

```bash
npx tdb
```

### Configuration Options

The CLI tool supports the following options:

- **`-o, --output <path>`**: Specifies the path to the output CSS file where dynamic breakpoints CSS will be written.
  - Default: `./dynamic-breakpoints.css`
- **`-c, --config <path>`**: Specifies the path to your `tailwind.config.js` file. This is used by `tdb` to identify which content files to scan for dynamic classes and to configure Tailwind CSS for generating the utility styles.
  - Default: `tailwind.config.js`
- **`-w, --watch`**: Enables watch mode. In this mode, `tdb` continuously monitors the files specified in your `tailwind.config.js`'s `content` array. When changes are detected, it automatically re-scans, re-generates CSS, and re-executes any specified `--post-command`.
- **`-p, --post-command <command>`**: Specifies a shell command to execute after `tdb` successfully generates the CSS output file. This is extremely useful for chaining `tdb` with your main Tailwind CSS compilation step or other build tools, ensuring your final CSS is always up-to-date.
  - Example: `"npx tailwindcss -i ./src/input.css -o ./src/output.css"`

### Examples

#### Custom Output and Config

Generates CSS to `dist/custom-breakpoints.css` using a specific Tailwind config file located in `configs/tailwind.custom.js`:

```bash
npx tdb -o dist/custom-breakpoints.css -c configs/tailwind.custom.js
```

#### Watch Mode with Automatic Tailwind Compilation (Recommended for Development)

This is the most powerful and common use case for automating your development workflow. It ensures that every time you save a file containing dynamic breakpoint classes, your final CSS is automatically updated.

**Step 1: Integrate `tdb`'s output into your main CSS.**
First, ensure your primary CSS entry file (e.g., `src/input.css`, `src/app/globals.css`, or `styles/globals.css` in Next.js projects) imports the CSS file generated by `tdb`. The path in the `@import` rule must match the path specified in `tdb`'s `--output` option.

```css
/* src/input.css (or your project's main CSS entry point) */

@tailwind base;
@tailwind components;
@tailwind utilities;

@import "./styles/generated.css"; /* <--- IMPORTANT: Path should match tdb's --output */

/* Your other global styles */
```

**Step 2: Run `tdb` with watch mode and the Tailwind compilation command.**
Keep this command running in a dedicated terminal during your development sessions:

```bash
npx tdb --output src/styles/generated.css --config tailwind.config.js --post-command "npx tailwindcss -i ./src/input.css -o ./src/output.css" --watch
```

Any time you add or modify dynamic breakpoint classes in your source files, `tdb` will regenerate `src/styles/generated.css`, and then automatically trigger `npx tailwindcss` to update your final `src/output.css`.

#### Production Build Integration

For production builds, it's crucial that `tdb` runs and generates its CSS _before_ your main project build process. You can effectively chain these commands in your `package.json` scripts:

```json
{
  "scripts": {
    "build:tdb": "npx tdb --output src/styles/generated.css --config tailwind.config.js",
    "build:css": "npm run build:tdb && npx tailwindcss -i ./src/input.css -o ./src/output.css",
    "build": "npm run build:css && next build" // Example for a Next.js project. Replace 'next build' with your project's actual build command (e.g., 'react-scripts build', 'vite build')
  }
}
```

Then, simply run `npm run build` (or `npm run build:css` if you only need the CSS part) to trigger the entire compilation sequence.

### Integration with Modern Frameworks (React, Next.js, Vite, etc.)

`tailwind-dynamic-breakpoints` is designed to be highly flexible and integrates seamlessly with various build setups. Its primary function is to generate the specific CSS for dynamic breakpoints into a file (e.g., `generated.css`). The way this file is finally integrated into your application's stylesheet depends on your framework's build system.

**Key Principle for Integration:**
Always **import the `tdb` generated CSS file (e.g., `generated.css`) into your project's main global CSS entry point.**

- **React (Create React App, Vite, Custom Webpack):**
  Your `generated.css` should be `@import`ed into your primary global CSS file (e.g., `src/index.css`, `src/App.css`). In development mode (`npm start` or `npm run dev`), modern bundlers (Webpack, Vite) are highly efficient at detecting changes in imported CSS files. When `tdb` updates `generated.css`, the bundler automatically recompiles and triggers Hot Module Replacement (HMR), meaning you typically **won't need the `--post-command`** for development watch mode, as your dev server handles the final CSS refresh. For production, ensure `npm run build:tdb` runs before your framework's build command (`react-scripts build`, `vite build`).
- **Next.js:**
  Import `generated.css` into your global CSS file (e.g., `src/app/globals.css` for App Router or `styles/globals.css` for Pages Router). Next.js's development server (with Fast Refresh) will automatically pick up changes to `generated.css` when `tdb` updates it. Similar to React, the `--post-command` might not be strictly necessary for watch mode if `next dev` is already running. For production, ensure `tdb` runs before `next build` (e.g., `npm run build:tdb && next build`).

<!-- end list -->

## Notes and Potential Improvements

This tool provides a powerful foundation for working with dynamic breakpoints in Tailwind CSS. As with any new utility, there are areas for future enhancements and considerations for optimal use:

- **Robust Error Handling**: While basic error handling is implemented to catch immediate issues, a more comprehensive and user-friendly error reporting mechanism is recommended for production environments. This could include more specific messages for common configuration mistakes, file access problems, or issues during CSS generation.
- **Tailwind Configuration (`content` field)**: It is crucial that your `tailwind.config.js` is correctly set up, especially the `content` field. `tdb` relies on this configuration to accurately scan your project files for dynamic breakpoint classes. Incorrect or missing paths here will prevent `tdb` from finding and generating CSS for your dynamic classes.
- **Performance for Large Projects**: For very large projects with a substantial number of files or extremely frequent changes, the current watch mode's re-scanning and re-generation process could potentially be optimized. Future improvements might include incremental scanning, more intelligent caching strategies, or parallel processing to speed up regeneration times.
- **Custom Utilities Validation**: The tool's ability to generate CSS for a given utility class (e.g., `text-black`, `text-[var(--primary)]`, or a custom utility like `my-custom-utility`) depends entirely on how Tailwind CSS itself processes and generates that utility. Ensure any custom utility classes you use with dynamic breakpoints are properly defined and generated by your `tailwind.config.js`. If Tailwind cannot generate CSS for a specific utility, `tdb` will not be able to either, and a warning will be logged.
- **Unit Tests**: Implementing a comprehensive suite of unit tests for the core logic, including class parsing, CSS generation, and CLI argument handling, is highly recommended. This will ensure stability, reliability, and ease of future maintenance and feature additions as the project grows.
- **Extensibility**: As a build tool, `tdb` could be extended with more advanced features. For example, a plugin system could allow users to define custom parsing rules beyond the current regex or integrate more deeply with specific PostCSS plugins.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
