// lib/generator.js
const postcss = require('postcss');
const tailwindcss = require('tailwindcss');

/**
 * Generates CSS from parsed dynamic breakpoint classes using Tailwind CSS and PostCSS.
 * @param {Object.<string, {type: string, value: string, utilityClass: string}>} files - Parsed dynamic classes.
 * @param {Object} tailwindConfig - The Tailwind CSS configuration object.
 * @returns {Promise<string>} The generated CSS string.
*/
async function generateCss(files, tailwindConfig) {
  if (Object.keys(files).length === 0) {
    return '/* No dynamic breakpoints found. */\n';
  }

  // 1. Create temporary CSS with @apply for all found utilities
  const utilityClasses = [...new Set(Object.values(files).map(f => f.utilityClass))];
  
  const tempCss = utilityClasses.map(cls => {
    const safeClsName = cls.replace(/[^a-zA-Z0-9\-_]/g, '');
    return `.tdb-generated-${safeClsName} { @apply ${cls}; }`;
  }).join('\n');
  
  // 2. Process temporary CSS using PostCSS and Tailwind
  const processor = postcss([tailwindcss(tailwindConfig)]);
  let result;
  try {
    result = await processor.process(tempCss, { from: undefined });
  } catch (error) {
    console.error('Error processing temporary CSS with PostCSS/Tailwind:', error.message);
    throw error;
  }
  
  const compiledUtilities = {};
  
  result.root.walkRules(rule => {
    if (rule.selector.startsWith('.tdb-generated-')) {
      const safeClsName = rule.selector.substring('.tdb-generated-'.length);
      const originalUtilityClass = utilityClasses.find(cls => cls.replace(/[^a-zA-Z0-9\-_]/g, '') === safeClsName);

      if (originalUtilityClass) {
          compiledUtilities[originalUtilityClass] = rule.nodes
            .filter(node => node.type === 'decl')
            .map(node => node.toString())
            .join('; ');
      }
    }
  });

  // Prepare classes for sorting
  const rulesForSorting = [];
  for (const fullClass in files) {
    const { type, value, utilityClass } = files[fullClass];
    rulesForSorting.push({ fullClass, type, value: parseInt(value, 10), utilityClass });
  }

  // Separate and sort max-width and min-width rules
  const maxRules = rulesForSorting.filter(rule => rule.type === 'max');
  const minRules = rulesForSorting.filter(rule => rule.type === 'min');

  // Sort max-width rules in descending order (e.g., 1400, 900, 600)
  maxRules.sort((a, b) => b.value - a.value); 
  // Sort min-width rules in ascending order (e.g., 500, 999)
  minRules.sort((a, b) => a.value - b.value);

  // Combine max-width rules first, then min-width rules
  const finalSortedRules = [...maxRules, ...minRules];

  // Assemble the final CSS, wrapping compiled styles in media queries
  let finalCss = '/* Generated by tailwind-dynamic-breakpoints */\n\n';
  
  for (const rule of finalSortedRules) { // Iterate over the sorted array
    const { fullClass, type, value, utilityClass } = rule;
    const mediaRule = `@media (${type === 'max' ? 'max-width' : 'min-width'}: ${value}px)`;
    const compiledCss = compiledUtilities[utilityClass];
    
    if (compiledCss && compiledCss.trim() !== '') {
        const escapedClass = fullClass
          .replace(/:/g, '\\:')
          .replace(/\//g, '\\/')
          .replace(/\[/g, '\\[')
          .replace(/\]/g, '\\]')
          .replace(/\./g, '\\.')
          .replace(/%/g, '\\%');
        
        finalCss += `${mediaRule} {\n  .${escapedClass} { ${compiledCss} }\n}\n\n`;
    } else {
      console.warn(`Warning: No compiled CSS found for utility class "${utilityClass}" extracted from "${fullClass}". This might indicate an issue with your Tailwind configuration or a custom utility that Tailwind doesn't generate CSS for.`);
    }
  }

  return finalCss;
}

module.exports = { generateCss };