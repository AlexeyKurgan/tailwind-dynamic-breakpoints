const postcss = require('postcss');
const tailwindcss = require('tailwindcss');

/**
 * Generates CSS from parsed dynamic breakpoint classes using Tailwind CSS and PostCSS.
 * @param {Object.<string, {type: string, value: string, utilityClass: string}>} files - Parsed dynamic classes.
 * @param {Object} tailwindConfig - The Tailwind CSS configuration object.
 * @returns {Promise<string>} The generated CSS string.
 */
async function generateCss(files, tailwindConfig) {
  if (Object.keys(files).length === 0) {
    return '/* No dynamic breakpoints found. */\n';
  }

  // 1. Create temporary CSS with @apply for all found utilities
  // This will allow Tailwind to generate the styles we need.
  // Use a Set for unique utilities.
  const utilityClasses = [...new Set(Object.values(files).map(f => f.utilityClass))];
  
  // Create "dummy" classes so Tailwind generates styles for @apply
  const tempCss = utilityClasses.map(cls => {
    // Sanitize the class name for use in the selector to avoid CSS issues.
    // Replace all non-alphanumeric characters (except hyphen and underscore) with an empty string.
    // This is necessary for generating correct selectors that Tailwind can process.
    const safeClsName = cls.replace(/[^a-zA-Z0-9\-_]/g, '');
    return `.tdb-generated-${safeClsName} { @apply ${cls}; }`;
  }).join('\n');
  
  // 2. Process temporary CSS using PostCSS and Tailwind
  const processor = postcss([tailwindcss(tailwindConfig)]);
  let result;
  try {
    result = await processor.process(tempCss, { from: undefined });
  } catch (error) {
    console.error('Error processing temporary CSS with PostCSS/Tailwind:', error.message);
    throw error;
  }
  
  const compiledUtilities = {};
  
  result.root.walkRules(rule => {
    // Look for selectors that start with '.tdb-generated-'
    if (rule.selector.startsWith('.tdb-generated-')) {
      // Extract the original utility name from the generated selector
      const safeClsName = rule.selector.substring('.tdb-generated-'.length);
      const originalUtilityClass = utilityClasses.find(cls => cls.replace(/[^a-zA-Z0-9\-_]/g, '') === safeClsName);

      if (originalUtilityClass) {
          // Store "clean" CSS for the utility, without the '.tdb-generated-*' selector
          // Filter out empty lines or comments
          compiledUtilities[originalUtilityClass] = rule.nodes
            .filter(node => node.type === 'decl') // Only get declarations
            .map(node => node.toString())
            .join('; ');
      }
    }
  });

  // 3. Assemble the final CSS, wrapping compiled styles in media queries
  let finalCss = '/* Generated by tailwind-dynamic-breakpoints */\n\n';
  for (const fullClass in files) {
    const { type, value, utilityClass } = files[fullClass];
    // Use `px` for media queries, as it's the most common unit for breakpoints.
    const mediaRule = `@media (${type === 'max' ? 'max-width' : 'min-width'}: ${value}px)`;
    const compiledCss = compiledUtilities[utilityClass];
    
    if (compiledCss && compiledCss.trim() !== '') {
        // Escape special characters for use in CSS selectors.
        // Tailwind uses special rules for escaping characters in arbitrary values.
        // For example, ':' becomes '\:', '[' becomes '\[', ']' becomes '\]', '/' becomes '\/'.
        // This is important for the browser to parse the selector correctly.
        const escapedClass = fullClass
            .replace(/:/g, '\\:')
            .replace(/\//g, '\\/')
            .replace(/\[/g, '\\[')
            .replace(/\]/g, '\\]')
            .replace(/\./g, '\\.')
            .replace(/%/g, '\\%'); // Also escape percent if it can be in the class
        
        finalCss += `${mediaRule} {\n  .${escapedClass} { ${compiledCss} }\n}\n\n`;
    } else {
      console.warn(`Warning: No compiled CSS found for utility class "${utilityClass}" extracted from "${fullClass}". This might indicate an issue with your Tailwind configuration or a custom utility that Tailwind doesn't generate CSS for.`);
    }
  }

  return finalCss;
}

module.exports = { generateCss };